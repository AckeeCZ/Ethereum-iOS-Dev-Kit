// Generated using ContractGen

import ReactiveSwift
import EtherKit
import BigInt

protocol {{ contractName}}: EthereumCommand {
    static func foo(bar: String, amount: BigInt, onSuccess: @escaping () -> Message) -> Self
}

extension {{ contractName }} {
{% for function in functions %}
  static func {{ function.name }}({{ function.params }}, amount: BigInt, onSuccess: @escaping () -> Message) {
    guard let data = params.data(using: .utf8) else { fatalError() }
    Run.send(rawTransaction: data, onSuccess: { _ in })
  }
{% endfor %}
}

extension EtherQuery {
  func {% filter lowerFirstLetter %}{{ contractName }}{% endfilter %}(at: String) -> EtherQuery {
    return self
  }
  {% for function in functions %}
  func {{ function.name }}({{ function.params}}) -> (_ using: EtherKeyManager, _ from: Address, _ to: Address, _ amount: UInt256) -> SignalProducer<Hash, EtherKitError> {
        return { using, from, to, amount in
            return SignalProducer<Hash, EtherKitError> { observer, disposable in
                //pass the params representing calling this function in the proper format to etherkit
                guard let paramsData = "foo(bar: \(bar)".data(using: .utf8) else {
                    observer.send(error: EtherKitError.web3Failure(reason: .parsingFailure))
                    return
                }
                self.send(using: using, from: from, to: to, value: amount, data: GeneralData(data: paramsData), completion: { result in
                    switch result {
                    case .success(let hash):
                        observer.send(value: hash)
                    case .failure(let error):
                        observer.send(error: error)
                        observer.sendCompleted()
                    }
                })
            }
        }
    }
{% endfor %}}
