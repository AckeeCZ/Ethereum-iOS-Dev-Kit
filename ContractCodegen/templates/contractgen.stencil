// Generated using ContractGen

import ReactiveSwift
import EtherKit
import BigInt

struct {{ contractName }}Box {
    fileprivate let etherQuery: EtherQuery
    fileprivate let at: Address

    init(etherQuery: EtherQuery, at: Address) {
        self.etherQuery = etherQuery
        self.at = at
    }
    {% for function in functions %}
    func {{ function.name }}({{ function.params }}) -> ContractMethodInvocation {
        let send: Send = { using, from, amount in
            return SignalProducer<Hash, EtherKitError> { observer, disposable in
                let {{ function.name }}FunctionCall = Function(name: "{{ function.name }}", parameters: [{{ function.values }}])
                let {{ function.name }}Data = GeneralData(data: {{ function.name }}FunctionCall.encodeToCall())
                self.etherQuery.send(using: using, from: from, to: self.at, value: amount, data: {{ function.name }}Data, completion: { result in
                    switch result {
                    case .success(let hash):
                        observer.send(value: hash)
                    case .failure(let error):
                        observer.send(error: error)
                        observer.sendCompleted()
                    }
                })
            }
        }
        return ContractMethodInvocation(send: send)
    }
{% endfor %}}

extension EtherQuery {
    func {% filter lowerFirstLetter %}{{ contractName }}{% endfilter %}(at: Address) -> {{ contractName }}Box {
        return {{ contractName }}Box(etherQuery: self, at: at)
    }
}

