// Generated using ContractGen

import ReactiveSwift
import EtherKit
import BigInt

typealias Send = (_ using: EtherKeyManager, _ from: Address, _ amount: UInt256) -> SignalProducer<Hash, EtherKitError>

struct ContractMethodInvocation {
    private let send: Send

    init(send: @escaping Send) {
        self.send = send
    }

    func send(using: EtherKeyManager, from: Address, amount: UInt256) -> SignalProducer<Hash, EtherKitError> {
        return self.send(using, from, amount)
    }
}

extension EtherQuery {
    func {{ lowercasedContractName }}(at: Address) -> {{ contractName }}Box {
        return {{ contractName }}Box(etherQuery: self, at: at)
    }
}

struct {{ contractName }}Box {
    fileprivate let etherQuery: EtherQuery
    fileprivate let at: Address

    init(etherQuery: EtherQuery, at: Address) {
        self.etherQuery = etherQuery
        self.at = at
    }

    {% for function in functions %}
    func {{ function.name }}({{ function.params }}) -> ContractMethodInvocation {
      let send: Send = { using, from, amount in
            return SignalProducer<Hash, EtherKitError> { observer, disposable in
                let {{ function.name }}FunctionCall = Function(functionSelector: FunctionSelector(name: "{{ function.name }}", parameterTypes: [{{ function.parameterTypes }}]), parameters: [{{ function.values }}])
                let {{ function.name }}Data = GeneralData(data: {{ function.name }}FunctionCall.encodeToCall())
                self.etherQuery.send(using: using, from: from, to: self.at, value: amount, data: {{ function.name }}Data, completion: { result in
                    switch result {
                    case .success(let hash):
                        observer.send(value: hash)
                    case .failure(let error):
                        observer.send(error: error)
                        observer.sendCompleted()
                    }
                })
            }
        }
        return ContractMethodInvocation(send: send)
      }
    {% endfor %}
}
