// Generated using ContractGen

import ReactiveSwift
import EtherKit
import BigInt
import ContractCodegenFramework

protocol {{ contractName }}: EthereumCommand { {% for function in functions %}
  static func {{ function.name }}({{ function.params }}, amount: BigInt, onSuccess: @escaping () -> Message) -> Run<Message>
} {% endfor %}

extension {{ contractName }} { {% for function in functions %}
  static func {{ function.name }}({{ function.params }}, amount: BigInt, onSuccess: @escaping () -> Message) -> Run<Message> {
    return Run { etherKit, callback in
      print("calling foo")
      let data: Data = NSKeyedArchiver.archivedData(withRootObject: [{{ function.paramsDict }}])
      Run.send(rawTransaction: data, onSuccess: { _ in onSuccess()}).run(etherKit, callback)
      print("did call foo")
    }
  }{% endfor %}
}

extension EtherQuery {
  func {% filter lowerFirstLetter %}{{ contractName }}{% endfilter %}(at: String) -> EtherQuery {
    return self
  }
  {% for function in functions %}
  func {{ function.name }}({{ function.params }}) -> (_ using: EtherKeyManager, _ from: Address, _ to: Address, _ amount: UInt256) -> SignalProducer<Hash, EtherKitError> {
        return { using, from, to, amount in
            return SignalProducer<Hash, EtherKitError> { observer, disposable in
                //pass the params representing calling this function in the proper format to etherkit
                guard let paramsData = "{{ function.name }}({{ function.callingParams }})".data(using: .utf8) else {
                    observer.send(error: EtherKitError.web3Failure(reason: .parsingFailure))
                    return
                }
                self.send(using: using, from: from, to: to, value: amount, data: GeneralData(data: paramsData), completion: { result in
                    switch result {
                    case .success(let hash):
                        observer.send(value: hash)
                    case .failure(let error):
                        observer.send(error: error)
                        observer.sendCompleted()
                    }
                })
            }
        }
    }
{% endfor %}}
